/* USER CODE BEGIN Header */
/**
  ******************************************************************************
  * @file           : main.c
  * @brief          : Main program body
  ******************************************************************************
  * @attention
  *
  * Copyright (c) 2025 STMicroelectronics.
  * All rights reserved.
  *
  * This software is licensed under terms that can be found in the LICENSE file
  * in the root directory of this software component.
  * If no LICENSE file comes with this software, it is provided AS-IS.
  *
  ******************************************************************************
  */
/* USER CODE END Header */
/* Includes ------------------------------------------------------------------*/
#include "main.h"
#include "dac.h"
#include "dma.h"
#include "spi.h"
#include "tim.h"
#include "usart.h"
#include "gpio.h"

/* Private includes ----------------------------------------------------------*/
/* USER CODE BEGIN Includes */
#include "stdio.h"
#include "ads1256.h"
#include "string.h"
#include "ctype.h"
#include "dac8554.h"
/* USER CODE END Includes */

/* Private typedef -----------------------------------------------------------*/
/* USER CODE BEGIN PTD */
// Current measurement channel structure (only save current channel data)
typedef struct {
    uint8_t curr_ch;      // Current selected differential channel (0-3)
    int32_t curr_adc;     // Current channel ADC raw value
    int32_t curr_volt;    // Current channel voltage value (keep original calculation)
} ADS_MEAS_T;
/* USER CODE END PTD */

/* Private define ------------------------------------------------------------*/
/* USER CODE BEGIN PD */
//dither data
const uint16_t wave_buffer[100]={2048,2061,2073,2085,2098,2110,2122,2133,2144,2155,2166,2175,2185,2194,
	2202,2210,2217,2223,2229,2234,2238,2242,2244,2246,2248,2248,2248,2246,2244,2242,2238,2234,2229,2223,
	2217,2210,2202,2194,2185,2175,2166,2155,2144,2133,2122,2110,2098,2085,2073,2061,2048,2035,2023,2011,
	1998,1986,1974,1963,1952,1941,1930,1921,1911,1902,1894,1886,1879,1873,1867,1862,1858,1854,1852,1850,
	1848,1848,1848,1850,1852,1854,1858,1862,1867,1873,1879,1886,1894,1902,1911,1921,1930,1941,1952,1963,
1974,1986,1998,2011,2023,2035};



// USART redirect
int fputc(int ch, FILE *f)
{
  while(HAL_UART_Transmit(&huart3, (uint8_t *)&ch, 1, 0xffff)!=HAL_OK);
  return ch;
}

int fgetc(FILE *f)
{
	volatile char c=0;
  while(HAL_UART_Receive(&huart3, (uint8_t *)&c, 1, 0xffff)!=HAL_OK);
  return c;
}

// Global variables
uint8_t Flag_DRDY;
ADS_MEAS_T g_tMeas = {.curr_ch = 0}; // Default channel 0
/* USER CODE END PD */

/* Private macro -------------------------------------------------------------*/
/* USER CODE BEGIN PM */

/* USER CODE END PM */

/* Private variables ---------------------------------------------------------*/

/* USER CODE BEGIN PV */

/* USER CODE END PV */

/* Private function prototypes -----------------------------------------------*/
void SystemClock_Config(void);
/* USER CODE BEGIN PFP */
void ADS1256_SwitchChannel(uint8_t ch); // Switch differential channel
void USART_ProcessCmd(void);             // USART command processing
/* USER CODE END PFP */

/* Private user code ---------------------------------------------------------*/
/* USER CODE BEGIN 0 */

/* USER CODE END 0 */

/**
  * @brief  The application entry point.
  * @retval int
  */
int main(void)
{

  /* USER CODE BEGIN 1 */
	int32_t iTemp;
	char infoBackPC[64];
  /* USER CODE END 1 */

  /* MCU Configuration--------------------------------------------------------*/

  /* Reset of all peripherals, Initializes the Flash interface and the Systick. */
  HAL_Init();

  /* USER CODE BEGIN Init */

  /* USER CODE END Init */

  /* Configure the system clock */
  SystemClock_Config();

  /* USER CODE BEGIN SysInit */

  /* USER CODE END SysInit */

  /* Initialize all configured peripherals */
  MX_GPIO_Init();
  MX_DMA_Init();
  MX_SPI3_Init();
  MX_USART3_UART_Init();
  MX_TIM3_Init();
  MX_SPI2_Init();
  MX_DAC1_Init();
  MX_TIM6_Init();
  /* USER CODE BEGIN 2 */
	/* Stop ADS1256 DRDY interrupt */
	ADS1256_StopScan();
	
	// Stable delay
	HAL_Delay(100);
	
	// ADS1256 Initialization
	bsp_InitADS1256();
	
	// Print chip ID
	uint8_t id;
	id = ADS1256_ReadChipID();
	printf("\r\n");
	printf("Reading ADS1256 ID... ...\r\n");
	if (id != 3)
	{
		sprintf(infoBackPC, "Error, ADS1256 Chip ID = 0x%X", id);
	}
	else
	{
		sprintf(infoBackPC, "Success, ADS1256 Chip ID = 0x%X", id);
	}
	printf("%s,%d\r\n",(uint8_t*)infoBackPC, strlen(infoBackPC));

	// Configure ADC: PGA=1, DRATE=30kSPS, differential 4 channels mode
	printf("\r\nPGA = 1, Sample Rate = 30ksps, 4 differential channels mode\r\n\r\n");
	ADS1256_CfgADC(ADS1256_GAIN_1, ADS1256_30000SPS);
	ADS1256_StartScan(1);	/* Start interrupt scan mode. 1=4 differential channels */
	
	// Default switch to channel 0
	ADS1256_SwitchChannel(0);
	printf("Input a/b/c/d via USART to switch to channel 0/1/2/3, only print current channel data\r\n");
	Flag_DRDY = 0;
	
	
	float aa=4.0f;
	//DAC init
	DAC_WriteA(aa);
	DAC_WriteB(3);
	DAC_WriteC(2);
	DAC_WriteD(1);
	
	
	
	
	//Dither0-(MCU)DAC1-init
	/**
  * @brief  打开多路复用开关的通道
  * @note   INH=AP5   INH=0 开关可以用 INH=1 所有开关禁用
		        A，B = PA6，PA7 = 0，0/1，0/0，1/1，1 = 通道0/1/2/3打开 = DITHER1/2/3/4输出
  */
	HAL_GPIO_WritePin(DAC_INH_GPIO_Port, DAC_INH_Pin, GPIO_PIN_RESET);//INH=0 开关可以用 INH=1 所有开关禁用
		
	//选择通道0 对应DITHER1
	HAL_GPIO_WritePin(DAC_SWITCHA_GPIO_Port, DAC_SWITCHA_Pin, GPIO_PIN_RESET);
	HAL_GPIO_WritePin(DAC_SWITCHB_GPIO_Port, DAC_SWITCHB_Pin, GPIO_PIN_RESET);

/**
  * @brief  DAC产生DITHER0
  * @note   必须最后启动事件更新的时钟TIM6否则会卡死
  */	
	//
	HAL_DAC_Start(&hdac1,DAC_CHANNEL_1);
	HAL_DAC_Start_DMA(&hdac1,DAC_CHANNEL_1,(uint32_t*)wave_buffer,100,DAC_ALIGN_12B_R);
	HAL_TIM_Base_Start(&htim6);
	
  /* USER CODE END 2 */

  /* Infinite loop */
  /* USER CODE BEGIN WHILE */
  while (1)
  {
    /* USER CODE END WHILE */

    /* USER CODE BEGIN 3 */
	// Process USART command (switch channel)
	USART_ProcessCmd();
	
	// Print data only when current channel data is ready
	if(Flag_DRDY >= 1)
	{
		Flag_DRDY = 0;
		if(aa<=4.7){aa+=0.1f;DAC_WriteA(aa);}else{aa=4.0f;DAC_WriteA(aa);}
		// Read current channel data (only save current channel, overwrite previous)
		g_tMeas.curr_adc = ADS1256_GetAdc(g_tMeas.curr_ch);
		
		// Keep original voltage calculation logic
		g_tMeas.curr_volt = ((int64_t)g_tMeas.curr_adc * 2493000) / 4194303;	
		
		// Print current channel data (English format)
		iTemp = g_tMeas.curr_volt;
		char ch_label = 'a' + g_tMeas.curr_ch; // Channel 0→a, 1→b...
		if (iTemp < 0)
		{
			iTemp = -iTemp;
			sprintf(infoBackPC, "Channel%c(CH%d)=%6d,(-%d.%03d %03d V)", 
					ch_label, g_tMeas.curr_ch, g_tMeas.curr_adc, 
					iTemp /1000000, (iTemp%1000000)/1000, iTemp%1000);
		}
		else
		{
			sprintf(infoBackPC,"Channel%c(CH%d)=%6d,( %d.%03d %03d V)", 
					ch_label, g_tMeas.curr_ch, g_tMeas.curr_adc, 
					iTemp/1000000, (iTemp%1000000)/1000, iTemp%1000);
		}
		printf("%s\r\n", infoBackPC);
		HAL_Delay(300);
		
	}
  }
  /* USER CODE END 3 */
}

/**
  * @brief System Clock Configuration
  * @retval None
  */
void SystemClock_Config(void)
{
  RCC_OscInitTypeDef RCC_OscInitStruct = {0};
  RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};

  /** Configure the main internal regulator output voltage
  */
  HAL_PWREx_ControlVoltageScaling(PWR_REGULATOR_VOLTAGE_SCALE1_BOOST);

  /** Initializes the RCC Oscillators according to the specified parameters
  * in the RCC_OscInitTypeDef structure.
  */
  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI;
  RCC_OscInitStruct.HSIState = RCC_HSI_ON;
  RCC_OscInitStruct.HSICalibrationValue = RCC_HSICALIBRATION_DEFAULT;
  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
  RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSI;
  RCC_OscInitStruct.PLL.PLLM = RCC_PLLM_DIV1;
  RCC_OscInitStruct.PLL.PLLN = 21;
  RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV2;
  RCC_OscInitStruct.PLL.PLLQ = RCC_PLLQ_DIV2;
  RCC_OscInitStruct.PLL.PLLR = RCC_PLLR_DIV2;
  if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
  {
    Error_Handler();
  }

  /** Initializes the CPU, AHB and APB buses clocks
  */
  RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
                              |RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2;
  RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
  RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
  RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV4;
  RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;

  if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_4) != HAL_OK)
  {
    Error_Handler();
  }
}

/* USER CODE BEGIN 4 */
/**
  * @brief  Switch differential channel (only save current channel)
  * @param  ch: Target channel (0-3)
  * @retval None
  */
void ADS1256_SwitchChannel(uint8_t ch)
{
  if (ch > 3) return;
  g_tMeas.curr_ch = ch;
  ADS1256_SetDiffChannal(ch);
  printf("\r\nSwitched to Channel%c(CH%d)\r\n", 'a'+ch, ch);
}

/**
  * @brief  USART command processing (a/b/c/d switch to channel 0/1/2/3)
  * @retval None
  */
void USART_ProcessCmd(void)
{
  if (__HAL_UART_GET_FLAG(&huart3, UART_FLAG_RXNE) != RESET)
  {
    char cmd = tolower(fgetc(stdin)); // Convert to lowercase, compatible with uppercase input
    switch(cmd)
    {
      case 'a': ADS1256_SwitchChannel(0); break;
      case 'b': ADS1256_SwitchChannel(1); break;
      case 'c': ADS1256_SwitchChannel(2); break;
      case 'd': ADS1256_SwitchChannel(3); break;
      default: 
        printf("Invalid command! Please input a/b/c/d to switch channel\r\n"); 
        break;
    }
    __HAL_UART_CLEAR_FLAG(&huart3, UART_FLAG_RXNE); // Clear receive flag
  }
}

/**
  * @brief  EXTI line detection callbacks.
  * @param  GPIO_Pin: Specifies the pins connected EXTI line
  * @retval None
  */
void HAL_GPIO_EXTI_Callback(uint16_t GPIO_Pin)
{
  if(GPIO_Pin == ADS_DRDY_Pin)
  {
    ADS1256_ISR();
    // Only count DRDY interrupt of current selected channel
    if (g_tADS1256.Channel == g_tMeas.curr_ch)
    {
      Flag_DRDY ++;
    }
  }
}
/* USER CODE END 4 */

/**
  * @brief  This function is executed in case of error occurrence.
  * @retval None
  */
void Error_Handler(void)
{
  /* USER CODE BEGIN Error_Handler_Debug */
  /* User can add his own implementation to report the HAL error return state */
  __disable_irq();
  while (1)
  {
  }
  /* USER CODE END Error_Handler_Debug */
}
#ifdef USE_FULL_ASSERT
/**
  * @brief  Reports the name of the source file and the source line number
  *         where the assert_param error has occurred.
  * @param  file: pointer to the source file name
  * @param  line: assert_param error line source number
  * @retval None
  */
void assert_failed(uint8_t *file, uint32_t line)
{
  /* USER CODE BEGIN 6 */
  /* User can add his own implementation to report the file name and line number,
     ex: printf("Wrong parameters value: file %s on line %d\r\n", file, line) */
  /* USER CODE END 6 */
}
#endif /* USE_FULL_ASSERT */
